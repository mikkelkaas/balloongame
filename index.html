<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#87CEEB">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Balloon Game">
    <link rel="manifest" href="manifest.json">
    <title>Balloon Shooter Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: linear-gradient(to bottom, #87CEEB 0%, #E0F6FF 100%);
            font-family: 'Arial', sans-serif;
        }

        #gameCanvas {
            display: block;
            cursor: crosshair;
            background: transparent;
        }

        #score {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 48px;
            font-weight: bold;
            color: #fff;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }



        .cloud {
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 100px;
            z-index: 1;
        }
    </style>
</head>
<body>
    <div id="score">Score: 0</div>
    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');

        // Set canvas size
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Game variables
        let score = 0;
        let balloons = [];
        let balloonId = 0;

        // Balloon images
        const goodBalloonImages = [];
        const badBalloonImage = new Image();
        let imagesLoaded = 0;
        const totalImages = 4; // 3 good + 1 bad

        // Load good balloon images
        for (let i = 1; i <= 2; i++) {
            const img = new Image();
            img.src = `good${i}.png`;
            img.onload = () => {
                imagesLoaded++;
                checkImagesLoaded();
            };
            img.onerror = () => {
                console.warn(`Could not load good${i}.png, using fallback`);
                imagesLoaded++;
                checkImagesLoaded();
            };
            goodBalloonImages.push(img);
        }

        // Load bad balloon image
        badBalloonImage.src = 'bad.png';
        badBalloonImage.onload = () => {
            imagesLoaded++;
            checkImagesLoaded();
        };
        badBalloonImage.onerror = () => {
            console.warn('Could not load bad.png, using fallback');
            imagesLoaded++;
            checkImagesLoaded();
        };

        let gameStarted = false;

        function checkImagesLoaded() {
            if (imagesLoaded === totalImages && !gameStarted) {
                gameStarted = true;
                gameLoop();
            }
        }

        // Balloon class
        class Balloon {
            constructor() {
                this.id = balloonId++;
                this.isGood = Math.random() > 0.3; // 70% good, 30% bad
                this.size = 60 + Math.random() * 40; // Random size between 60-100
                this.x = Math.random() * (canvas.width - this.size);
                this.y = canvas.height + this.size;
                this.speed = 1 + Math.random() * 2; // Speed between 1-3
                this.swingAngle = Math.random() * Math.PI * 2;
                this.swingSpeed = 0.02 + Math.random() * 0.03;
                this.swingAmount = 20 + Math.random() * 30;
                this.rotation = Math.random() * 0.4 - 0.2;
                
                if (this.isGood) {
                    this.image = goodBalloonImages[Math.floor(Math.random() * goodBalloonImages.length)];
                } else {
                    this.image = badBalloonImage;
                }
            }

            update() {
                this.y -= this.speed;
                this.swingAngle += this.swingSpeed;
                this.rotation += 0.001;
            }

            draw() {
                const swingOffset = Math.sin(this.swingAngle) * this.swingAmount;
                const drawX = this.x + swingOffset;

                ctx.save();
                ctx.translate(drawX + this.size / 2, this.y + this.size / 2);
                ctx.rotate(this.rotation);

                // Try to draw image, fallback to colored circle if image not loaded
                if (this.image && this.image.complete && this.image.naturalWidth > 0) {
                    ctx.drawImage(this.image, -this.size / 2, -this.size / 2, this.size, this.size);
                } else {
                    // Fallback: draw colored circles
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size / 2, 0, Math.PI * 2);
                    ctx.fillStyle = this.isGood ? '#FF6B6B' : '#4A4A4A';
                    ctx.fill();
                    ctx.strokeStyle = this.isGood ? '#FF0000' : '#000000';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Add a shine effect
                    ctx.beginPath();
                    ctx.arc(-this.size / 6, -this.size / 6, this.size / 6, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                    ctx.fill();
                }

                // Draw string
                ctx.strokeStyle = 'rgba(100, 100, 100, 0.5)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, this.size / 2);
                ctx.lineTo(0, this.size / 2 + 30);
                ctx.stroke();

                ctx.restore();
            }

            isClicked(mouseX, mouseY) {
                const swingOffset = Math.sin(this.swingAngle) * this.swingAmount;
                const drawX = this.x + swingOffset;
                const dx = mouseX - (drawX + this.size / 2);
                const dy = mouseY - (this.y + this.size / 2);
                const distance = Math.sqrt(dx * dx + dy * dy);
                return distance < this.size / 2;
            }

            isOffScreen() {
                return this.y + this.size < 0;
            }
        }

        // Particle effect for popping
        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 10;
                this.vy = (Math.random() - 0.5) * 10;
                this.size = Math.random() * 8 + 3;
                this.life = 1;
                this.color = color;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += 0.3; // Gravity
                this.life -= 0.02;
            }

            draw() {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }

            isDead() {
                return this.life <= 0;
            }
        }

        let particles = [];

        function createPopEffect(x, y, isGood) {
            const colors = isGood 
                ? ['#FF6B6B', '#FF8E8E', '#FFB5B5', '#FFC9C9']
                : ['#4A4A4A', '#6B6B6B', '#8C8C8C', '#A0A0A0'];
            
            for (let i = 0; i < 15; i++) {
                const color = colors[Math.floor(Math.random() * colors.length)];
                particles.push(new Particle(x, y, color));
            }
        }

        // Spawn balloons periodically
        function spawnBalloon() {
            balloons.push(new Balloon());
        }

        // Initial balloon spawn
        setInterval(spawnBalloon, 1500); // Spawn a balloon every 1.5 seconds

        // Handle clicks
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            for (let i = balloons.length - 1; i >= 0; i--) {
                if (balloons[i].isClicked(mouseX, mouseY)) {
                    const balloon = balloons[i];
                    const swingOffset = Math.sin(balloon.swingAngle) * balloon.swingAmount;
                    const popX = balloon.x + swingOffset + balloon.size / 2;
                    const popY = balloon.y + balloon.size / 2;
                    
                    createPopEffect(popX, popY, balloon.isGood);
                    
                    if (balloon.isGood) {
                        score += 1;
                    } else {
                        score -= 5;
                    }
                    
                    scoreDisplay.textContent = `Score: ${score}`;
                    balloons.splice(i, 1);
                    break; // Only pop one balloon per click
                }
            }
        });

        // Draw background clouds
        function drawClouds() {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            
            // Static clouds (you can make them move if you want)
            const clouds = [
                { x: 100, y: 80, size: 60 },
                { x: 400, y: 150, size: 80 },
                { x: 700, y: 100, size: 70 },
                { x: 1000, y: 200, size: 90 },
            ];

            clouds.forEach(cloud => {
                // Main cloud circles
                ctx.beginPath();
                ctx.arc(cloud.x, cloud.y, cloud.size * 0.5, 0, Math.PI * 2);
                ctx.arc(cloud.x + cloud.size * 0.4, cloud.y, cloud.size * 0.4, 0, Math.PI * 2);
                ctx.arc(cloud.x - cloud.size * 0.4, cloud.y, cloud.size * 0.4, 0, Math.PI * 2);
                ctx.arc(cloud.x, cloud.y - cloud.size * 0.3, cloud.size * 0.35, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        // Game loop
        function gameLoop() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw clouds
            drawClouds();

            // Update and draw balloons
            for (let i = balloons.length - 1; i >= 0; i--) {
                balloons[i].update();
                balloons[i].draw();

                // Remove balloons that have floated off screen
                if (balloons[i].isOffScreen()) {
                    balloons.splice(i, 1);
                }
            }

            // Update and draw particles
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update();
                particles[i].draw();

                if (particles[i].isDead()) {
                    particles.splice(i, 1);
                }
            }

            requestAnimationFrame(gameLoop);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        // Start the game after a short delay if images haven't loaded yet
        setTimeout(() => {
            if (!gameStarted) {
                console.log('Starting game with fallback graphics');
                gameStarted = true;
                gameLoop();
            }
        }, 1000);
    </script>
</body>
</html>
