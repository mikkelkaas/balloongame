<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#87CEEB">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Balloon Game">
    <link rel="manifest" href="manifest.json">
    <title>Balloon Shooter Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: linear-gradient(to bottom, #87CEEB 0%, #E0F6FF 100%);
            font-family: 'Arial', sans-serif;
        }

        #gameCanvas {
            display: block;
            cursor: crosshair;
            background: transparent;
        }

        #score {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 48px;
            font-weight: bold;
            color: #fff;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        #level {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 32px;
            font-weight: bold;
            color: #fff;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        #levelUp {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 64px;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.8);
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }



        .cloud {
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 100px;
            z-index: 1;
        }
    </style>
</head>
<body>
    <div id="score">Ballonner: 0</div>
    <div id="level">Bane: 1</div>
    <div id="levelUp">NY BANE! ðŸŽ‰</div>
    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const levelDisplay = document.getElementById('level');
        const levelUpDisplay = document.getElementById('levelUp');

        // Set canvas size
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Game variables
        let score = 0;
        let level = 1;
        let balloons = [];
        let balloonId = 0;
        let speedMultiplier = 1;
        let spawnInterval = 1500;

        // Balloon images
        const goodBalloonImages = [];
        const badBalloonImage = new Image();
        let imagesLoaded = 0;
        const totalImages = 3; // 2 good + 1 bad

        // Load good balloon images
        for (let i = 1; i <= 2; i++) {
            const img = new Image();
            img.src = `good${i}.png`;
            img.onload = () => {
                imagesLoaded++;
                checkImagesLoaded();
            };
            img.onerror = () => {
                console.warn(`Could not load good${i}.png, using fallback`);
                imagesLoaded++;
                checkImagesLoaded();
            };
            goodBalloonImages.push(img);
        }

        // Load bad balloon image
        badBalloonImage.src = 'bad.png';
        badBalloonImage.onload = () => {
            imagesLoaded++;
            checkImagesLoaded();
        };
        badBalloonImage.onerror = () => {
            console.warn('Could not load bad.png, using fallback');
            imagesLoaded++;
            checkImagesLoaded();
        };

        let gameStarted = false;

        function checkImagesLoaded() {
            if (imagesLoaded === totalImages && !gameStarted) {
                gameStarted = true;
                gameLoop();
            }
        }

        // Balloon class
        class Balloon {
            constructor() {
                this.id = balloonId++;
                this.isGood = Math.random() > 0.3; // 70% good, 30% bad
                this.size = 60 + Math.random() * 40; // Random size between 60-100
                this.x = Math.random() * (canvas.width - this.size);
                this.y = canvas.height + this.size;
                this.speed = (0.5 + Math.random() * 1) * speedMultiplier; // Speed affected by level
                this.swingAngle = Math.random() * Math.PI * 2;
                this.swingSpeed = 0.02 + Math.random() * 0.03;
                this.swingAmount = 20 + Math.random() * 30;
                this.rotation = Math.random() * 0.4 - 0.2;
                
                if (this.isGood) {
                    this.image = goodBalloonImages[Math.floor(Math.random() * goodBalloonImages.length)];
                } else {
                    this.image = badBalloonImage;
                }
            }

            update() {
                this.y -= this.speed;
                this.swingAngle += this.swingSpeed;
                this.rotation += 0.001;
            }

            draw() {
                const swingOffset = Math.sin(this.swingAngle) * this.swingAmount;
                const drawX = this.x + swingOffset;

                ctx.save();
                ctx.translate(drawX + this.size / 2, this.y + this.size / 2);
                ctx.rotate(this.rotation);

                // Try to draw image, fallback to colored circle if image not loaded
                if (this.image && this.image.complete && this.image.naturalWidth > 0) {
                    ctx.drawImage(this.image, -this.size / 2, -this.size / 2, this.size, this.size);
                } else {
                    // Fallback: draw colored circles
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size / 2, 0, Math.PI * 2);
                    ctx.fillStyle = this.isGood ? '#FF6B6B' : '#4A4A4A';
                    ctx.fill();
                    ctx.strokeStyle = this.isGood ? '#FF0000' : '#000000';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Add a shine effect
                    ctx.beginPath();
                    ctx.arc(-this.size / 6, -this.size / 6, this.size / 6, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                    ctx.fill();
                }

                // Draw string
                ctx.strokeStyle = 'rgba(100, 100, 100, 0.5)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, this.size / 2);
                ctx.lineTo(0, this.size / 2 + 30);
                ctx.stroke();

                ctx.restore();
            }

            isClicked(mouseX, mouseY) {
                const swingOffset = Math.sin(this.swingAngle) * this.swingAmount;
                const drawX = this.x + swingOffset;
                const dx = mouseX - (drawX + this.size / 2);
                const dy = mouseY - (this.y + this.size / 2);
                const distance = Math.sqrt(dx * dx + dy * dy);
                return distance < this.size / 2;
            }

            isOffScreen() {
                return this.y + this.size < 0;
            }
        }

        // Particle effect for popping
        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 10;
                this.vy = (Math.random() - 0.5) * 10;
                this.size = Math.random() * 8 + 3;
                this.life = 1;
                this.color = color;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += 0.3; // Gravity
                this.life -= 0.02;
            }

            draw() {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }

            isDead() {
                return this.life <= 0;
            }
        }

        let particles = [];

        // Initialize clouds with drift properties
        const clouds = [
            { x: 100, y: 80, size: 60, speed: -0.1 },
            { x: 400, y: 150, size: 80, speed: 0.15 },
            { x: 700, y: 100, size: 70, speed: 0.8 },
            { x: 1000, y: 200, size: 90, speed: 0.12 },
            { x: 1000, y: 180, size: 20, speed: -0.42 },
            // { x: 1000, y: 200, size: 90, speed: 0.12 },
            { x: 1300, y: 130, size: 75, speed: 0.2 }
        ];

        function createPopEffect(x, y, isGood) {
            const colors = isGood 
                ? ['#FF6B6B', '#FF8E8E', '#FFB5B5', '#FFC9C9']
                : ['#4A4A4A', '#6B6B6B', '#8C8C8C', '#A0A0A0'];
            
            for (let i = 0; i < 15; i++) {
                const color = colors[Math.floor(Math.random() * colors.length)];
                particles.push(new Particle(x, y, color));
            }
        }

        // Spawn balloons periodically
        function spawnBalloon() {
            balloons.push(new Balloon());
        }

        // Dynamic balloon spawning
        let lastSpawnTime = Date.now();
        
        function updateSpawning() {
            const now = Date.now();
            if (now - lastSpawnTime >= spawnInterval) {
                spawnBalloon();
                lastSpawnTime = now;
            }
        }
        
        // Level up function
        function checkLevelUp() {
            const newLevel = Math.floor(score / 20) + 1;
            if (newLevel > level) {
                level = newLevel;
                speedMultiplier = 1 + (level - 1) * 0.5; // Increase speed by 50% per level
                spawnInterval = Math.max(400, 1500 - (level - 1) * 150); // Faster spawning, min 400ms
                
                levelDisplay.textContent = `Bane: ${level}`;
                
                // Show level up animation
                levelUpDisplay.style.opacity = '1';
                setTimeout(() => {
                    levelUpDisplay.style.opacity = '0';
                }, 2000);
            }
        }

        // Handle clicks
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            for (let i = balloons.length - 1; i >= 0; i--) {
                if (balloons[i].isClicked(mouseX, mouseY)) {
                    const balloon = balloons[i];
                    const swingOffset = Math.sin(balloon.swingAngle) * balloon.swingAmount;
                    const popX = balloon.x + swingOffset + balloon.size / 2;
                    const popY = balloon.y + balloon.size / 2;
                    
                    createPopEffect(popX, popY, balloon.isGood);
                    
                    if (balloon.isGood) {
                        score += 1;
                    } else {
                        score -= 5;
                    }
                    
                    scoreDisplay.textContent = `Ballonner: ${score}`;
                    checkLevelUp();
                    balloons.splice(i, 1);
                    break; // Only pop one balloon per click
                }
            }
        });

        // Draw and update background clouds
        function drawClouds() {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            
            clouds.forEach(cloud => {
                // Update cloud position
                cloud.x += cloud.speed;
                
                // Wrap cloud around when it goes off screen (bidirectional)
                if (cloud.speed > 0 && cloud.x > canvas.width + cloud.size * 2) {
                    // Moving right, wrap to left
                    cloud.x = -cloud.size * 2;
                } else if (cloud.speed < 0 && cloud.x < -cloud.size * 2) {
                    // Moving left, wrap to right
                    cloud.x = canvas.width + cloud.size * 2;
                }
                
                // Main cloud circles
                ctx.beginPath();
                ctx.arc(cloud.x, cloud.y, cloud.size * 0.5, 0, Math.PI * 2);
                ctx.arc(cloud.x + cloud.size * 0.4, cloud.y, cloud.size * 0.4, 0, Math.PI * 2);
                ctx.arc(cloud.x - cloud.size * 0.4, cloud.y, cloud.size * 0.4, 0, Math.PI * 2);
                ctx.arc(cloud.x, cloud.y - cloud.size * 0.3, cloud.size * 0.35, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        // Game loop
        function gameLoop() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Update spawning
            updateSpawning();

            // Draw clouds
            drawClouds();

            // Update and draw balloons
            for (let i = balloons.length - 1; i >= 0; i--) {
                balloons[i].update();
                balloons[i].draw();

                // Remove balloons that have floated off screen
                if (balloons[i].isOffScreen()) {
                    balloons.splice(i, 1);
                }
            }

            // Update and draw particles
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update();
                particles[i].draw();

                if (particles[i].isDead()) {
                    particles.splice(i, 1);
                }
            }

            requestAnimationFrame(gameLoop);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        // Start the game after a short delay if images haven't loaded yet
        setTimeout(() => {
            if (!gameStarted) {
                console.log('Starting game with fallback graphics');
                gameStarted = true;
                gameLoop();
            }
        }, 1000);
    </script>
</body>
</html>
